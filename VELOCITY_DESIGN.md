# Velocity Proxy Integration - Design Document

## Overview
Velocity is the **killer feature** for PayPerPlay - it enables automatic server wakeup when players connect, making the Pay-Per-Play model seamless.

## Architecture

### High-Level Flow
```
Player connects → Velocity Proxy (always on) → Backend API → Docker starts server → Player transferred
```

### Components

#### 1. Velocity Proxy Container
- **Purpose**: Always-on proxy listening on port 25565
- **Image**: `itzg/bungeecord` with TYPE=VELOCITY
- **Configuration**: Dynamic velocity.toml generated by backend
- **Custom Plugin**: Handles server wakeup logic

#### 2. Velocity Wakeup Plugin (Java)
- **Trigger**: Player attempts to connect to offline server
- **Action**:
  - Show "Server starting..." message
  - Call backend API: `POST /api/internal/servers/{id}/wakeup`
  - Poll server status: `GET /api/internal/servers/{id}/status`
  - Transfer player when ready

#### 3. Backend API Extensions
New endpoints needed:
- `POST /api/internal/servers/{id}/wakeup` - Start server
- `GET /api/internal/servers/{id}/status` - Check if server is ready
- `POST /api/internal/velocity/reload` - Reload Velocity config
- `GET /api/internal/velocity/servers` - List all servers for Velocity

#### 4. Database Schema Updates
Add to MinecraftServer model:
```go
VelocityRegistered bool      // Is registered with Velocity?
VelocityServerName string    // Server name in Velocity (e.g., "survival-1")
```

---

## Implementation Plan

### Phase 1: Velocity Container Setup (Day 1)

#### Files to Create:
1. **internal/velocity/velocity_service.go** - Velocity container management
2. **internal/velocity/config_generator.go** - Generate velocity.toml
3. **internal/velocity/plugin/** - Custom wakeup plugin (Java)

#### Velocity Service Interface:
```go
type VelocityService struct {
    docker     *docker.DockerService
    cfg        *config.Config
    containerID string
}

func (v *VelocityService) Start() error
func (v *VelocityService) Stop() error
func (v *VelocityService) RegisterServer(server *models.MinecraftServer) error
func (v *VelocityService) UnregisterServer(serverID string) error
func (v *VelocityService) ReloadConfig() error
func (v *VelocityService) IsRunning() bool
```

#### Velocity Container Specs:
```yaml
Image: itzg/bungeecord:latest
Environment:
  - TYPE=VELOCITY
  - MEMORY=512M
Ports:
  - 25565:25577 (Velocity default port)
  - 25566:25566 (Velocity API port for plugin)
Volumes:
  - ./velocity/config:/config
  - ./velocity/plugins:/plugins
Networks:
  - minecraft-network (bridge with backend containers)
```

---

### Phase 2: Wakeup Plugin (Day 1-2)

#### Plugin Structure (Java/Kotlin):
```
velocity-wakeup-plugin/
├── src/main/java/com/payperplay/
│   ├── WakeupPlugin.java         # Main plugin class
│   ├── ServerConnectListener.java # Listen for player connections
│   ├── BackendAPIClient.java     # HTTP client for backend
│   └── WakeupHandler.java        # Wakeup logic
├── build.gradle
└── velocity-plugin.json
```

#### Key Plugin Logic:
```java
@Subscribe
public void onServerPreConnect(ServerPreConnectEvent event) {
    Player player = event.getPlayer();
    RegisteredServer server = event.getResult().getServer();

    // Check if server is online
    if (!isServerOnline(server)) {
        event.setResult(ServerPreConnectEvent.ServerResult.denied());
        player.sendMessage("§eServer starting... Please wait.");

        // Trigger wakeup
        CompletableFuture.runAsync(() -> {
            wakeupServer(server.getServerInfo().getName());
            waitForServerReady(server);
            player.createConnectionRequest(server).connect();
        });
    }
}
```

#### Backend API Integration:
```java
public class BackendAPIClient {
    private static final String API_URL = "http://backend:8000/api/internal";

    public void wakeupServer(String serverID) {
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(API_URL + "/servers/" + serverID + "/wakeup"))
            .POST(HttpRequest.BodyPublishers.noBody())
            .build();
        httpClient.send(request, HttpResponse.BodyHandlers.ofString());
    }

    public boolean isServerReady(String serverID) {
        // Poll /api/internal/servers/{id}/status
        // Return true when status == "running"
    }
}
```

---

### Phase 3: Backend API Extensions (Day 2)

#### New API Endpoints:

**File**: `internal/api/velocity_handlers.go`

```go
type VelocityHandler struct {
    velocityService *velocity.VelocityService
    mcService       *service.MinecraftService
}

// POST /api/internal/servers/:id/wakeup
func (h *VelocityHandler) WakeupServer(c *gin.Context) {
    serverID := c.Param("id")

    // Start server if not running
    server, err := h.mcService.GetServer(serverID)
    if server.Status != "running" {
        err := h.mcService.StartServer(serverID)
        if err != nil {
            c.JSON(500, gin.H{"error": err.Error()})
            return
        }
    }

    c.JSON(200, gin.H{"status": "starting"})
}

// GET /api/internal/servers/:id/status
func (h *VelocityHandler) GetServerStatus(c *gin.Context) {
    serverID := c.Param("id")
    server, err := h.mcService.GetServer(serverID)

    c.JSON(200, gin.H{
        "status": server.Status,
        "port": server.Port,
        "ready": server.Status == "running",
    })
}

// POST /api/internal/velocity/reload
func (h *VelocityHandler) ReloadVelocity(c *gin.Context) {
    err := h.velocityService.ReloadConfig()
    c.JSON(200, gin.H{"reloaded": true})
}
```

#### Router Updates:
```go
// Internal API (for Velocity plugin)
internal := router.Group("/api/internal")
{
    internal.POST("/servers/:id/wakeup", velocityHandler.WakeupServer)
    internal.GET("/servers/:id/status", velocityHandler.GetServerStatus)
    internal.POST("/velocity/reload", velocityHandler.ReloadVelocity)
}
```

---

### Phase 4: Configuration Management (Day 2-3)

#### velocity.toml Generator:

**File**: `internal/velocity/config_generator.go`

```go
type VelocityConfig struct {
    Servers map[string]ServerConfig
    Try     []string
    Forced  map[string][]string
}

type ServerConfig struct {
    Address string
    Motd    string
}

func (v *VelocityService) GenerateConfig() error {
    // Get all servers from database
    servers, _ := v.repo.FindAll()

    config := VelocityConfig{
        Servers: make(map[string]ServerConfig),
        Try:     []string{},
    }

    for _, server := range servers {
        config.Servers[server.VelocityServerName] = ServerConfig{
            Address: fmt.Sprintf("host.docker.internal:%d", server.Port),
            Motd: server.Name,
        }
        config.Try = append(config.Try, server.VelocityServerName)
    }

    // Write to velocity.toml
    return v.writeConfig(config)
}
```

#### Config Auto-Reload:
- When server is created → Regenerate velocity.toml + Reload Velocity
- When server is deleted → Regenerate velocity.toml + Reload Velocity
- When server port changes → Regenerate velocity.toml + Reload Velocity

---

### Phase 5: Server Lifecycle Integration (Day 3)

#### Update MinecraftService:

**File**: `internal/service/minecraft_service.go`

```go
func (s *MinecraftService) CreateServer(...) (*MinecraftServer, error) {
    // ... existing creation logic ...

    // Register with Velocity
    if s.velocityService != nil {
        server.VelocityServerName = s.generateVelocityName(server)
        server.VelocityRegistered = true
        err := s.velocityService.RegisterServer(server)
        if err != nil {
            logger.Warn("Failed to register with Velocity", map[string]interface{}{
                "server_id": server.ID,
                "error": err.Error(),
            })
        }
    }

    return server, nil
}

func (s *MinecraftService) DeleteServer(serverID string) error {
    // Unregister from Velocity first
    if s.velocityService != nil {
        s.velocityService.UnregisterServer(serverID)
    }

    // ... existing deletion logic ...
}

func (s *MinecraftService) generateVelocityName(server *MinecraftServer) string {
    // Generate unique Velocity server name
    // Example: "paper-1.20-xyz123" or "forge-1.19-abc456"
    return fmt.Sprintf("%s-%s", server.ServerType, server.ID[:8])
}
```

---

## Docker Network Architecture

```
┌─────────────────────────────────────────────┐
│  Host Machine                               │
│                                             │
│  ┌───────────────────────────────────────┐ │
│  │  Docker Network: minecraft-network    │ │
│  │                                       │ │
│  │  ┌─────────────────┐                 │ │
│  │  │ Velocity Proxy  │ (always on)     │ │
│  │  │ Port: 25565     │                 │ │
│  │  └────────┬────────┘                 │ │
│  │           │                          │ │
│  │  ┌────────┴───────────────┐         │ │
│  │  │                        │         │ │
│  │  ▼                        ▼         │ │
│  │  ┌──────────┐      ┌──────────┐    │ │
│  │  │ Server 1 │      │ Server 2 │    │ │
│  │  │ (Paper)  │      │ (Forge)  │    │ │
│  │  │ 25566    │      │ 25567    │    │ │
│  │  └──────────┘      └──────────┘    │ │
│  │                                     │ │
│  │  ┌─────────────────────┐           │ │
│  │  │ Backend API         │           │ │
│  │  │ Port: 8000          │           │ │
│  │  └─────────────────────┘           │ │
│  └───────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

---

## Configuration Examples

### velocity.toml (Generated):
```toml
[servers]
  survival-abc123 = "host.docker.internal:25566"
  creative-def456 = "host.docker.internal:25567"

[forced-hosts]
  "survival.payperplay.com" = ["survival-abc123"]
  "creative.payperplay.com" = ["creative-def456"]

try = ["survival-abc123"]
```

### Velocity Plugin Config (velocity-wakeup.toml):
```toml
backend-api = "http://host.docker.internal:8000"
wakeup-timeout = 60
wakeup-message = "§eServer starting... This may take 10-30 seconds."
ready-check-interval = 2
```

---

## Player Experience Flow

### Scenario: Player connects to offline server

1. **Player connects** to play.payperplay.com:25565
2. **Velocity receives** connection
3. **Velocity checks** if target server is online
4. **Server is offline** → Plugin intercepts
5. **Player sees** "Server starting... Please wait."
6. **Plugin calls** `POST /api/internal/servers/{id}/wakeup`
7. **Backend starts** Docker container
8. **Plugin polls** `GET /api/internal/servers/{id}/status` every 2s
9. **Container ready** (status = "running")
10. **Plugin transfers** player to server automatically
11. **Player joins** - seamless experience!

---

## Benefits of This Architecture

### For Users:
- **Zero waiting** - Connect and server auto-starts
- **Transparent** - Looks like server is always online
- **Fast** - Usually 10-20 seconds to start

### For PayPerPlay:
- **Cost savings** - Servers only run when used
- **Scalability** - Velocity can handle 1000+ servers
- **Reliability** - Velocity stays online even if backend restarts

---

## Testing Plan

### Manual Tests:
1. Start Velocity container
2. Create test server via API
3. Verify server registered in velocity.toml
4. Stop test server
5. Connect with Minecraft client
6. Verify wakeup message appears
7. Verify server starts automatically
8. Verify player is transferred once ready

### Automated Tests:
- Unit tests for config generator
- Integration tests for API endpoints
- Mock Velocity connection for wakeup flow

---

## Rollout Strategy

### Development (Local):
1. Run Velocity + Backend + 1 test server
2. Test wakeup flow manually
3. Verify config regeneration

### Staging:
1. Deploy to Hetzner with 2-3 test servers
2. Stress test with multiple concurrent connections
3. Monitor latency and resource usage

### Production:
1. Deploy Velocity with monitoring
2. Gradually enable for new servers
3. Migration path for existing servers

---

## Security Considerations

### Internal API:
- `/api/internal/*` endpoints should be **internal only**
- Use Docker network isolation
- No public access to wakeup endpoints

### Velocity Plugin:
- Validate server IDs before wakeup
- Rate limit wakeup requests per player
- Log all wakeup attempts

---

## Performance Metrics

### Target Metrics:
- Wakeup time: <30 seconds (average)
- Velocity latency: <50ms
- Config reload time: <1 second
- Max concurrent wakeups: 10

### Monitoring:
- Track wakeup success rate
- Monitor Velocity resource usage (512MB RAM)
- Alert on failed wakeups

---

## File Structure Summary

```
PayPerPlayHosting/
├── internal/
│   ├── velocity/
│   │   ├── velocity_service.go      # Velocity container management
│   │   ├── config_generator.go      # velocity.toml generation
│   │   └── models.go                # Velocity-specific models
│   ├── api/
│   │   └── velocity_handlers.go     # Internal API endpoints
├── velocity/
│   ├── config/
│   │   └── velocity.toml            # Generated config
│   ├── plugins/
│   │   └── velocity-wakeup-1.0.jar  # Custom plugin
│   └── plugin-src/                  # Java plugin source
│       ├── build.gradle
│       └── src/main/java/...
└── VELOCITY_DESIGN.md               # This file
```

---

## Next Steps

1. ✅ Complete backend integration (done)
2. ⏳ Implement Velocity service (next)
3. ⏳ Build wakeup plugin
4. ⏳ Add internal API endpoints
5. ⏳ Test end-to-end flow

---

**Status**: Ready for implementation
**Estimated Time**: 3-4 days
**Priority**: HIGH - This is the killer feature!
